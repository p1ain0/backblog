---
title: CVE-2021-3156分析
date: 2021-09-07 15:41:58
tags: 漏洞分析
---

## 漏洞复现

```shell
sudoedit -s '\' `perl -e 'print "A" x 64'`
```

崩了

## 漏洞分析

如果sudo在一个shell环境中被执行了：

- 使用 -s 参数选项设置sudo的MODE_SHELL标志；
- 或者通过 -i 参数选项设置sudo的MODE_SHELL和MODE_LOGIN_SHELL标志；然后在sudo的main()的开头调用parse_args()重写argv

```c++
   /* Parse command line arguments. */
    sudo_mode = parse_args(argc, argv, &nargc, &nargv, &settings, &env_add);
    sudo_debug_printf(SUDO_DEBUG_DEBUG, "sudo_mode %d", sudo_mode);
```

直接定位到漏洞函数处：

```c++
    static int
set_cmnd(void)
{
    ......
    /* set user_args */
    if (NewArgc > 1) {
        char *to, *from, **av;
        size_t size, n;

        /* Alloc and build up user_args. */
        for (size = 0, av = NewArgv + 1; *av; av++)
        size += strlen(*av) + 1;
        if (size == 0 || (user_args = malloc(size)) == NULL) {
        sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
        debug_return_int(-1);
        }
        if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
        /*
         * When running a command via a shell, the sudo front-end
         * escapes potential meta chars.  We unescape non-spaces
         * for sudoers matching and logging purposes.
         */
        for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
            while (*from) {
            if (from[0] == '\\' && !isspace((unsigned char)from[1]))
                from++;
            *to++ = *from++;
            }
            *to++ = ' ';
        }
        *--to = '\0';
        } else {
        for (to = user_args, av = NewArgv + 1; *av; av++) {
            n = strlcpy(to, *av, size - (to - user_args));
            if (n >= size - (to - user_args)) {
            sudo_warnx(U_("internal error, %s overflow"), __func__);
            debug_return_int(-1);
            }
            to += n;
            *to++ = ' ';
        }
        *--to = '\0';
        }
    }
    }

    if ((user_base = strrchr(user_cmnd, '/')) != NULL)
    user_base++;
    else
    user_base = user_cmnd;

    if (!update_defaults(SETDEF_CMND, false)) {
    log_warningx(SLOG_SEND_MAIL|SLOG_NO_STDERR,
        N_("problem with defaults entries"));
    }

    debug_return_int(ret);
}
```

若from[0]为\并且from[1]是NULL结束字符（不为空格），因此进入if条件 from++后此时指向NULL结束字符，而下一行from++指向下个字符串开头，若该字符串存在，则继续这个while循环，因此造成了堆溢出。通过动态调试可见，程序越界读取\后的“AAAAA....”字符，进入下一轮while循环：

## 漏洞利用

Qualys团队提供了三种漏洞利用手段：

1.`struct sudo_hook_entry`覆盖:

sudo程序在process_hooks_getenv()函数crash了；因为我们直接覆盖了函数getenv_fn()的指针。一个`struct sudo_hook_entry`的结构体，修改`struct sudo_hook_entry`实例可以实现任意代码执行的目的。

但是这里会有一个其他的问题，就是ASLR，我们可以通过部分写入的方式绕过ASLR，

2.`struct service_user`覆盖

Qualys团队分析第二个cash，发现crash在了nss_load_library()的函数上。crash的原因是我们覆盖了library的指针。我们可以通过重写`struct service_user`结构体，实现任意代码的执行。我们把`ni->library`覆盖为NULL,`ni->name`(初始化为systemd)覆盖为X/X,

service_user结构体实现如下：

```c++
//nss/nsswitch.h#L61
typedef struct service_user
{
  /* And the link to the next entry.  */
  struct service_user *next;
  /* Action according to result.  */
  lookup_actions actions[5];
  /* Link to the underlying library object.  */
  service_library *library;
  /* Collection of known functions.  */
  void *known;
  /* Name of the service (`files', `dns', `nis', ...).  */
  char name[0];
} service_user;
```

```c++
------------------------------------------------------------------------
327 static int
328 nss_load_library (service_user *ni)
329 {
330   if (ni->library == NULL)
331     {
...
338       ni->library = nss_new_service (service_table ?: &default_table,
339                                      ni->name);
...
342     }
343
344   if (ni->library->lib_handle == NULL)
345     {
346       /* Load the shared library.  */
347       size_t shlen = (7 + strlen (ni->name) + 3
348                       + strlen (__nss_shlib_revision) + 1);
349       int saved_errno = errno;
350       char shlib_name[shlen];
351
352       /* Construct shared object name.  */
353       __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
354                                               "libnss_"),
355                                     ni->name),
356                           ".so"),
357                 __nss_shlib_revision);
358
359       ni->library->lib_handle = __libc_dlopen (shlib_name);
------------------------------------------------------------------------
```

在353-357行，构造分享库名字为"libnss_X/X.so.2"，在359行从当前目录中加载名字为"libnss_X/X.so.2"的动态链接库。并执行_init构造函数。

3.def_timestampdir覆盖。

第三种利用方式不是直接从sudo的crash中，是通过观察获得的。在Fuzzing的时候sudo创建了数十个新的目录（AAAA AAAAA等），这些目录中的每一个都属于 root 并且只包含一个小的文件，以我自己的用户命名：sudo 的时间戳文件——我们显然覆盖了 def_timestampdir，sudo 的时间戳目录的名称。如果我们通过目录名覆盖def_timestampdir，然后我们可以与 sudo 的 ts_mkdirs() 竞争，创建一个符号链接到任意文件。
可以以root的身份打开这个任意文件，写struct timestamp_entry到它的里边。但是现在有两个问题：

(1)如果 Sudo 的 timestamp_open() 指向的文件早于启动时间，则会删除我们的任意符号链接。 我们能够通过创建一个非常旧的时间戳文件（来自 Unix 时代），等待直到 timestamp_open() 删除它，并通过与 timestamp_open() 竞争来创建我们最终的、任意的符号链接来解决第一个问题。

(2)我们不控制写入任意文件的 struct timestamp_entry 的内容。 据我们所知，我们只控制三个字节（进程 ID 或结构时间规范），我们无法将这个三字节写入转换为完全 root 权限。

然而我们可以通过sudo的timestamp_lock()的一个小bug规避掉第二个问题。如果我们在与 ts_mkdirs() 和 timestamp_open() 的两个之间利用，并且我们的任意符号链接指向 /etc/passwd，那么这个文件将以 root 身份打开，

```c++
------------------------------------------------------------------------
 65 struct timestamp_entry {
 66     unsigned short version;     /* version number */
 67     unsigned short size;        /* entry size */
 68     unsigned short type;        /* TS_GLOBAL, TS_TTY, TS_PPID */
 ..
 78 };
------------------------------------------------------------------------
 305 static ssize_t
 306 ts_write(int fd, const char *fname, struct timestamp_entry *entry, off_t offset)
 307 {
 ...
 318         nwritten = pwrite(fd, entry, entry->size, offset);
 ...
 350 }
------------------------------------------------------------------------
 619 bool
 620 timestamp_lock(void *vcookie, struct passwd *pw)
 621 {
 622     struct ts_cookie *cookie = vcookie;
 623     struct timestamp_entry entry;
 ...
 644     nread = read(cookie->fd, &entry, sizeof(entry));
 645     if (nread == 0) {
 ...
 652     } else if (entry.type != TS_LOCKEXCL) {
 ...
 657         if (ts_write(cookie->fd, cookie->fname, &entry, 0) == -1)
------------------------------------------------------------------------
```

在644行，/etc/passwd文件的头0x38字节被读到栈上的`timestamp_entry`结构体中,

在652行，`entry.type` is 0x783a (":x"), 不是TS_LOCKEXCL;

在657和318行,`entry->size`个字节，从栈上的entry被写到/etc/passwd中，但是`entry->size` 实际上是0x746f ("ot"), 不是sizeof(struct timestamp_entry)

之后我们向/etc/passwd中注入了一个与root拥有相同权限的新用户，从而完成提权。
